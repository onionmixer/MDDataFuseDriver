# WS13 DOS IOCTL Wrapper Audit

Date: 2026-02-17

## w31/extract/mdcache.exe
- wrapper_mem: `0x15b6`
- wrapper_prologue: `0x15b6`
- near_call_xrefs: 2

### Wrapper Body
```asm
0x15b6: push bp
0x15b7: mov bp, sp
0x15b9: push si
0x15ba: push di
0x15bb: push ds
0x15bc: lds dx, ptr [bp + 0xa]
0x15bf: mov ah, 0x44
0x15c1: mov al, byte ptr [bp + 8]
0x15c4: mov bx, word ptr [bp + 6]
0x15c7: mov cx, word ptr [bp + 0xe]
0x15ca: int 0x21
0x15cc: pop ds
0x15cd: jb 0x15db
0x15cf: cmp word ptr [bp + 8], 0
0x15d3: jne 0x15d9
0x15d5: mov ax, dx
0x15d7: jmp 0x15df
0x15d9: jmp 0x15df
0x15db: push ax
0x15dc: call 0x5aa
0x15df: pop di
0x15e0: pop si
0x15e1: pop bp
0x15e2: retf
0x15e3: push ax
0x15e4: push bx
0x15e5: push cx
0x15e6: push dx
0x15e7: push es
0x15e8: push ds
0x15e9: push si
0x15ea: push di
0x15eb: push bp
0x15ec: mov bp, 0xb8a
0x15ef: mov ds, bp
0x15f1: mov bp, sp
0x15f3: sub sp, 4
0x15f6: les bx, ptr [bp + 0x12]
0x15f9: cmp byte ptr es:[bx], 0x62
0x15fd: je 0x1606
0x15ff: pushf
0x1600: lcall [0x12f2]
0x1604: jmp 0x1659
0x1606: mov dx, word ptr [0xc95]
0x160a: mov ax, word ptr [0xc93]
0x160d: mov word ptr [bp - 2], dx
0x1610: mov word ptr [bp - 4], ax
0x1613: or dx, dx
0x1615: jne 0x161c
0x1617: cmp ax, 1
0x161a: je 0x1659
0x161c: mov ax, word ptr [bp - 4]
```

### Callsite Samples
- call_1: at `0x2347`, inferred AL arg `0x0000`
```asm
0x231b: inc si
0x231c: clc
0x231d: or ax, ax
0x231f: jl 0x2324
0x2321: jmp 0x23aa
0x2324: jmp 0x23ec
0x2327: push word ptr [bp + 0xa]
0x232a: push word ptr [bp + 8]
0x232d: push word ptr [bp + 6]
0x2330: nop
0x2331: push cs
0x2332: call 0x23f5
0x2335: add sp, 6
0x2338: mov word ptr [bp - 8], ax
0x233b: or ax, ax
0x233d: jl 0x23aa
0x233f: xor ax, ax
0x2341: push ax
0x2342: push word ptr [bp - 8]
0x2345: nop
0x2346: push cs
0x2347: call 0x15b6
```
- call_2: at `0x2371`, inferred AL arg `unknown`
```asm
0x2345: nop
0x2346: push cs
0x2347: call 0x15b6
0x234a: pop cx
0x234b: pop cx
0x234c: mov word ptr [bp - 4], ax
0x234f: test al, 0x80
0x2351: je 0x2379
0x2353: or word ptr [bp + 0xa], 0x2000
0x2358: test byte ptr [bp + 0xb], 0x80
0x235c: je 0x2385
0x235e: and ax, 0xff
0x2361: or ax, 0x20
0x2364: xor dx, dx
0x2366: push dx
0x2367: push ax
0x2368: mov ax, 1
0x236b: push ax
0x236c: push word ptr [bp - 8]
0x236f: nop
0x2370: push cs
0x2371: call 0x15b6
```

## w31/extract/mdformat.exe
- wrapper_mem: `0x2439`
- wrapper_prologue: `0x2439`
- near_call_xrefs: 2

### Wrapper Body
```asm
0x2439: push bp
0x243a: mov bp, sp
0x243c: push si
0x243d: push di
0x243e: push ds
0x243f: lds dx, ptr [bp + 0xa]
0x2442: mov ah, 0x44
0x2444: mov al, byte ptr [bp + 8]
0x2447: mov bx, word ptr [bp + 6]
0x244a: mov cx, word ptr [bp + 0xe]
0x244d: int 0x21
0x244f: pop ds
0x2450: jb 0x245e
0x2452: cmp word ptr [bp + 8], 0
0x2456: jne 0x245c
0x2458: mov ax, dx
0x245a: jmp 0x2462
0x245c: jmp 0x2462
0x245e: push ax
0x245f: call 0xe22
0x2462: pop di
0x2463: pop si
0x2464: pop bp
0x2465: retf
0x2466: push ax
0x2467: push bx
0x2468: push cx
0x2469: push dx
0x246a: push es
0x246b: push ds
0x246c: push si
0x246d: push di
0x246e: push bp
0x246f: mov bp, 0x170d
0x2472: mov ds, bp
0x2474: mov bp, sp
0x2476: sub sp, 4
0x2479: les bx, ptr [bp + 0x12]
0x247c: cmp byte ptr es:[bx], 0x62
0x2480: je 0x2489
0x2482: pushf
0x2483: lcall [0x3a02]
0x2487: jmp 0x24dc
0x2489: mov dx, word ptr [0x18b7]
0x248d: mov ax, word ptr [0x18b5]
0x2490: mov word ptr [bp - 2], dx
0x2493: mov word ptr [bp - 4], ax
0x2496: or dx, dx
0x2498: jne 0x249f
0x249a: cmp ax, 1
0x249d: je 0x24dc
0x249f: mov ax, word ptr [bp - 4]
```

### Callsite Samples
- call_1: at `0x3b92`, inferred AL arg `0x0000`
```asm
0x3b66: inc si
0x3b67: clc
0x3b68: or ax, ax
0x3b6a: jl 0x3b6f
0x3b6c: jmp 0x3bf5
0x3b6f: jmp 0x3c37
0x3b72: push word ptr [bp + 0xa]
0x3b75: push word ptr [bp + 8]
0x3b78: push word ptr [bp + 6]
0x3b7b: nop
0x3b7c: push cs
0x3b7d: call 0x3c40
0x3b80: add sp, 6
0x3b83: mov word ptr [bp - 8], ax
0x3b86: or ax, ax
0x3b88: jl 0x3bf5
0x3b8a: xor ax, ax
0x3b8c: push ax
0x3b8d: push word ptr [bp - 8]
0x3b90: nop
0x3b91: push cs
0x3b92: call 0x2439
```
- call_2: at `0x3bbc`, inferred AL arg `unknown`
```asm
0x3b90: nop
0x3b91: push cs
0x3b92: call 0x2439
0x3b95: pop cx
0x3b96: pop cx
0x3b97: mov word ptr [bp - 4], ax
0x3b9a: test al, 0x80
0x3b9c: je 0x3bc4
0x3b9e: or word ptr [bp + 0xa], 0x2000
0x3ba3: test byte ptr [bp + 0xb], 0x80
0x3ba7: je 0x3bd0
0x3ba9: and ax, 0xff
0x3bac: or ax, 0x20
0x3baf: xor dx, dx
0x3bb1: push dx
0x3bb2: push ax
0x3bb3: mov ax, 1
0x3bb6: push ax
0x3bb7: push word ptr [bp - 8]
0x3bba: nop
0x3bbb: push cs
0x3bbc: call 0x2439
```

## Findings
- Both wrappers set `AH=0x44` and call `int 0x21` (DOS IOCTL/device control class).
- Both wrappers load `AL` from stack argument (function code is caller-supplied).
- `mdcache` direct xrefs show `AL=0` and `AL=1` style callsites; no direct evidence here for `AL=2+`.
- This supports a conservative split: generic DOS IOCTL transport is confirmed;
  private MDCTL payload schema remains unresolved.
